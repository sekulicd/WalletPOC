// Code generated by protoc-gen-go. DO NOT EDIT.
// source: wallet.proto

package wallet

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GenSeedRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenSeedRequest) Reset()         { *m = GenSeedRequest{} }
func (m *GenSeedRequest) String() string { return proto.CompactTextString(m) }
func (*GenSeedRequest) ProtoMessage()    {}
func (*GenSeedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{0}
}

func (m *GenSeedRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenSeedRequest.Unmarshal(m, b)
}
func (m *GenSeedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenSeedRequest.Marshal(b, m, deterministic)
}
func (m *GenSeedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenSeedRequest.Merge(m, src)
}
func (m *GenSeedRequest) XXX_Size() int {
	return xxx_messageInfo_GenSeedRequest.Size(m)
}
func (m *GenSeedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenSeedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenSeedRequest proto.InternalMessageInfo

type GenSeedReply struct {
	//
	//seed_mnemonic is a 24-word mnemonic that encodes a prior seed obtained
	//by the user. This field is optional, as if not provided, then the daemon will
	//generate a new cipher seed for the user. Otherwise, then the daemon will
	//attempt to recover the wallet state linked to this cipher seed.
	SeedMnemonic         []string `protobuf:"bytes,1,rep,name=seed_mnemonic,json=seedMnemonic,proto3" json:"seed_mnemonic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenSeedReply) Reset()         { *m = GenSeedReply{} }
func (m *GenSeedReply) String() string { return proto.CompactTextString(m) }
func (*GenSeedReply) ProtoMessage()    {}
func (*GenSeedReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{1}
}

func (m *GenSeedReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenSeedReply.Unmarshal(m, b)
}
func (m *GenSeedReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenSeedReply.Marshal(b, m, deterministic)
}
func (m *GenSeedReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenSeedReply.Merge(m, src)
}
func (m *GenSeedReply) XXX_Size() int {
	return xxx_messageInfo_GenSeedReply.Size(m)
}
func (m *GenSeedReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GenSeedReply.DiscardUnknown(m)
}

var xxx_messageInfo_GenSeedReply proto.InternalMessageInfo

func (m *GenSeedReply) GetSeedMnemonic() []string {
	if m != nil {
		return m.SeedMnemonic
	}
	return nil
}

type InitWalletRequest struct {
	//
	//wallet_password is the passphrase that should be used to encrypt the
	//wallet. This MUST be at least 8 chars in length. After creation, this
	//password is required to unlock the daemon.
	WalletPassword []byte `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	//
	//seed_mnemonic is a 24-word mnemonic that encodes a prior seed obtained by the
	//user. This MUST be a generated by the GenSeed method
	SeedMnemonic         []string `protobuf:"bytes,2,rep,name=seed_mnemonic,json=seedMnemonic,proto3" json:"seed_mnemonic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitWalletRequest) Reset()         { *m = InitWalletRequest{} }
func (m *InitWalletRequest) String() string { return proto.CompactTextString(m) }
func (*InitWalletRequest) ProtoMessage()    {}
func (*InitWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{2}
}

func (m *InitWalletRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InitWalletRequest.Unmarshal(m, b)
}
func (m *InitWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InitWalletRequest.Marshal(b, m, deterministic)
}
func (m *InitWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitWalletRequest.Merge(m, src)
}
func (m *InitWalletRequest) XXX_Size() int {
	return xxx_messageInfo_InitWalletRequest.Size(m)
}
func (m *InitWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitWalletRequest proto.InternalMessageInfo

func (m *InitWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

func (m *InitWalletRequest) GetSeedMnemonic() []string {
	if m != nil {
		return m.SeedMnemonic
	}
	return nil
}

type InitWalletReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitWalletReply) Reset()         { *m = InitWalletReply{} }
func (m *InitWalletReply) String() string { return proto.CompactTextString(m) }
func (*InitWalletReply) ProtoMessage()    {}
func (*InitWalletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{3}
}

func (m *InitWalletReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InitWalletReply.Unmarshal(m, b)
}
func (m *InitWalletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InitWalletReply.Marshal(b, m, deterministic)
}
func (m *InitWalletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitWalletReply.Merge(m, src)
}
func (m *InitWalletReply) XXX_Size() int {
	return xxx_messageInfo_InitWalletReply.Size(m)
}
func (m *InitWalletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InitWalletReply.DiscardUnknown(m)
}

var xxx_messageInfo_InitWalletReply proto.InternalMessageInfo

type UnlockWalletRequest struct {
	//
	//wallet_password should be the current valid passphrase for the daemon. This
	//will be required to decrypt on-disk material that the daemon requires to
	//function properly.
	WalletPassword       []byte   `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockWalletRequest) Reset()         { *m = UnlockWalletRequest{} }
func (m *UnlockWalletRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockWalletRequest) ProtoMessage()    {}
func (*UnlockWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{4}
}

func (m *UnlockWalletRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnlockWalletRequest.Unmarshal(m, b)
}
func (m *UnlockWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnlockWalletRequest.Marshal(b, m, deterministic)
}
func (m *UnlockWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockWalletRequest.Merge(m, src)
}
func (m *UnlockWalletRequest) XXX_Size() int {
	return xxx_messageInfo_UnlockWalletRequest.Size(m)
}
func (m *UnlockWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockWalletRequest proto.InternalMessageInfo

func (m *UnlockWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

type UnlockWalletReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockWalletReply) Reset()         { *m = UnlockWalletReply{} }
func (m *UnlockWalletReply) String() string { return proto.CompactTextString(m) }
func (*UnlockWalletReply) ProtoMessage()    {}
func (*UnlockWalletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{5}
}

func (m *UnlockWalletReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnlockWalletReply.Unmarshal(m, b)
}
func (m *UnlockWalletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnlockWalletReply.Marshal(b, m, deterministic)
}
func (m *UnlockWalletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockWalletReply.Merge(m, src)
}
func (m *UnlockWalletReply) XXX_Size() int {
	return xxx_messageInfo_UnlockWalletReply.Size(m)
}
func (m *UnlockWalletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockWalletReply.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockWalletReply proto.InternalMessageInfo

type ChangePasswordRequest struct {
	//
	//current_password should be the current valid passphrase used to unlock the
	//daemon.
	CurrentPassword []byte `protobuf:"bytes,1,opt,name=current_password,json=currentPassword,proto3" json:"current_password,omitempty"`
	//
	//new_password should be the new passphrase that will be needed to unlock the
	//daemon.
	NewPassword          []byte   `protobuf:"bytes,2,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangePasswordRequest) Reset()         { *m = ChangePasswordRequest{} }
func (m *ChangePasswordRequest) String() string { return proto.CompactTextString(m) }
func (*ChangePasswordRequest) ProtoMessage()    {}
func (*ChangePasswordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{6}
}

func (m *ChangePasswordRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChangePasswordRequest.Unmarshal(m, b)
}
func (m *ChangePasswordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChangePasswordRequest.Marshal(b, m, deterministic)
}
func (m *ChangePasswordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePasswordRequest.Merge(m, src)
}
func (m *ChangePasswordRequest) XXX_Size() int {
	return xxx_messageInfo_ChangePasswordRequest.Size(m)
}
func (m *ChangePasswordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePasswordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePasswordRequest proto.InternalMessageInfo

func (m *ChangePasswordRequest) GetCurrentPassword() []byte {
	if m != nil {
		return m.CurrentPassword
	}
	return nil
}

func (m *ChangePasswordRequest) GetNewPassword() []byte {
	if m != nil {
		return m.NewPassword
	}
	return nil
}

type ChangePasswordReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangePasswordReply) Reset()         { *m = ChangePasswordReply{} }
func (m *ChangePasswordReply) String() string { return proto.CompactTextString(m) }
func (*ChangePasswordReply) ProtoMessage()    {}
func (*ChangePasswordReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{7}
}

func (m *ChangePasswordReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChangePasswordReply.Unmarshal(m, b)
}
func (m *ChangePasswordReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChangePasswordReply.Marshal(b, m, deterministic)
}
func (m *ChangePasswordReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePasswordReply.Merge(m, src)
}
func (m *ChangePasswordReply) XXX_Size() int {
	return xxx_messageInfo_ChangePasswordReply.Size(m)
}
func (m *ChangePasswordReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePasswordReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePasswordReply proto.InternalMessageInfo

type SendToManyRequest struct {
	//
	//A slice of the outputs that should be created in the transaction produced.
	Outputs []*TxOut `protobuf:"bytes,1,rep,name=outputs,proto3" json:"outputs,omitempty"`
	//
	//The number of millisatoshis per byte that should be used when crafting
	//this transaction.
	MillisatPerByte int64 `protobuf:"varint,2,opt,name=millisat_per_byte,json=millisatPerByte,proto3" json:"millisat_per_byte,omitempty"`
	// Optional: if true the transaction will be pushed to the network
	Push                 bool     `protobuf:"varint,3,opt,name=push,proto3" json:"push,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendToManyRequest) Reset()         { *m = SendToManyRequest{} }
func (m *SendToManyRequest) String() string { return proto.CompactTextString(m) }
func (*SendToManyRequest) ProtoMessage()    {}
func (*SendToManyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{8}
}

func (m *SendToManyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SendToManyRequest.Unmarshal(m, b)
}
func (m *SendToManyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SendToManyRequest.Marshal(b, m, deterministic)
}
func (m *SendToManyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToManyRequest.Merge(m, src)
}
func (m *SendToManyRequest) XXX_Size() int {
	return xxx_messageInfo_SendToManyRequest.Size(m)
}
func (m *SendToManyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToManyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendToManyRequest proto.InternalMessageInfo

func (m *SendToManyRequest) GetOutputs() []*TxOut {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *SendToManyRequest) GetMillisatPerByte() int64 {
	if m != nil {
		return m.MillisatPerByte
	}
	return 0
}

func (m *SendToManyRequest) GetPush() bool {
	if m != nil {
		return m.Push
	}
	return false
}

type SendToManyReply struct {
	//
	//The serialized transaction sent out on the network.
	RawTx                []byte   `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendToManyReply) Reset()         { *m = SendToManyReply{} }
func (m *SendToManyReply) String() string { return proto.CompactTextString(m) }
func (*SendToManyReply) ProtoMessage()    {}
func (*SendToManyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{9}
}

func (m *SendToManyReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SendToManyReply.Unmarshal(m, b)
}
func (m *SendToManyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SendToManyReply.Marshal(b, m, deterministic)
}
func (m *SendToManyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendToManyReply.Merge(m, src)
}
func (m *SendToManyReply) XXX_Size() int {
	return xxx_messageInfo_SendToManyReply.Size(m)
}
func (m *SendToManyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SendToManyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SendToManyReply proto.InternalMessageInfo

func (m *SendToManyReply) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

type WalletAddressRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalletAddressRequest) Reset()         { *m = WalletAddressRequest{} }
func (m *WalletAddressRequest) String() string { return proto.CompactTextString(m) }
func (*WalletAddressRequest) ProtoMessage()    {}
func (*WalletAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{10}
}

func (m *WalletAddressRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WalletAddressRequest.Unmarshal(m, b)
}
func (m *WalletAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WalletAddressRequest.Marshal(b, m, deterministic)
}
func (m *WalletAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletAddressRequest.Merge(m, src)
}
func (m *WalletAddressRequest) XXX_Size() int {
	return xxx_messageInfo_WalletAddressRequest.Size(m)
}
func (m *WalletAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WalletAddressRequest proto.InternalMessageInfo

type WalletAddressReply struct {
	// The confidential address encoded using a blech32 format.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The blinding private key for the given address encoded in hex format
	Blinding             string   `protobuf:"bytes,2,opt,name=blinding,proto3" json:"blinding,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalletAddressReply) Reset()         { *m = WalletAddressReply{} }
func (m *WalletAddressReply) String() string { return proto.CompactTextString(m) }
func (*WalletAddressReply) ProtoMessage()    {}
func (*WalletAddressReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{11}
}

func (m *WalletAddressReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WalletAddressReply.Unmarshal(m, b)
}
func (m *WalletAddressReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WalletAddressReply.Marshal(b, m, deterministic)
}
func (m *WalletAddressReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletAddressReply.Merge(m, src)
}
func (m *WalletAddressReply) XXX_Size() int {
	return xxx_messageInfo_WalletAddressReply.Size(m)
}
func (m *WalletAddressReply) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletAddressReply.DiscardUnknown(m)
}

var xxx_messageInfo_WalletAddressReply proto.InternalMessageInfo

func (m *WalletAddressReply) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *WalletAddressReply) GetBlinding() string {
	if m != nil {
		return m.Blinding
	}
	return ""
}

type BalanceInfo struct {
	// The balance of the wallet
	TotalBalance uint64 `protobuf:"varint,1,opt,name=total_balance,json=totalBalance,proto3" json:"total_balance,omitempty"`
	// The confirmed balance of a wallet(with >= 1 confirmations)
	ConfirmedBalance uint64 `protobuf:"varint,2,opt,name=confirmed_balance,json=confirmedBalance,proto3" json:"confirmed_balance,omitempty"`
	// The unconfirmed balance of a wallet(with 0 confirmations)
	UnconfirmedBalance   uint64   `protobuf:"varint,3,opt,name=unconfirmed_balance,json=unconfirmedBalance,proto3" json:"unconfirmed_balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BalanceInfo) Reset()         { *m = BalanceInfo{} }
func (m *BalanceInfo) String() string { return proto.CompactTextString(m) }
func (*BalanceInfo) ProtoMessage()    {}
func (*BalanceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{12}
}

func (m *BalanceInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BalanceInfo.Unmarshal(m, b)
}
func (m *BalanceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BalanceInfo.Marshal(b, m, deterministic)
}
func (m *BalanceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalanceInfo.Merge(m, src)
}
func (m *BalanceInfo) XXX_Size() int {
	return xxx_messageInfo_BalanceInfo.Size(m)
}
func (m *BalanceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BalanceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BalanceInfo proto.InternalMessageInfo

func (m *BalanceInfo) GetTotalBalance() uint64 {
	if m != nil {
		return m.TotalBalance
	}
	return 0
}

func (m *BalanceInfo) GetConfirmedBalance() uint64 {
	if m != nil {
		return m.ConfirmedBalance
	}
	return 0
}

func (m *BalanceInfo) GetUnconfirmedBalance() uint64 {
	if m != nil {
		return m.UnconfirmedBalance
	}
	return 0
}

type WalletBalanceRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalletBalanceRequest) Reset()         { *m = WalletBalanceRequest{} }
func (m *WalletBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*WalletBalanceRequest) ProtoMessage()    {}
func (*WalletBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{13}
}

func (m *WalletBalanceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WalletBalanceRequest.Unmarshal(m, b)
}
func (m *WalletBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WalletBalanceRequest.Marshal(b, m, deterministic)
}
func (m *WalletBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletBalanceRequest.Merge(m, src)
}
func (m *WalletBalanceRequest) XXX_Size() int {
	return xxx_messageInfo_WalletBalanceRequest.Size(m)
}
func (m *WalletBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WalletBalanceRequest proto.InternalMessageInfo

type WalletBalanceReply struct {
	// The balance info (total, confirmed, unconfirmed) of the wallet grouped by
	// asset
	Balance              map[string]*BalanceInfo `protobuf:"bytes,1,rep,name=balance,proto3" json:"balance,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *WalletBalanceReply) Reset()         { *m = WalletBalanceReply{} }
func (m *WalletBalanceReply) String() string { return proto.CompactTextString(m) }
func (*WalletBalanceReply) ProtoMessage()    {}
func (*WalletBalanceReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{14}
}

func (m *WalletBalanceReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WalletBalanceReply.Unmarshal(m, b)
}
func (m *WalletBalanceReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WalletBalanceReply.Marshal(b, m, deterministic)
}
func (m *WalletBalanceReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletBalanceReply.Merge(m, src)
}
func (m *WalletBalanceReply) XXX_Size() int {
	return xxx_messageInfo_WalletBalanceReply.Size(m)
}
func (m *WalletBalanceReply) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletBalanceReply.DiscardUnknown(m)
}

var xxx_messageInfo_WalletBalanceReply proto.InternalMessageInfo

func (m *WalletBalanceReply) GetBalance() map[string]*BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

type TxOut struct {
	// The asset being spent
	Asset string `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	// The value of the output being spent.
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	// The confidential address of the output being spent.
	Address              string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxOut) Reset()         { *m = TxOut{} }
func (m *TxOut) String() string { return proto.CompactTextString(m) }
func (*TxOut) ProtoMessage()    {}
func (*TxOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{15}
}

func (m *TxOut) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TxOut.Unmarshal(m, b)
}
func (m *TxOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TxOut.Marshal(b, m, deterministic)
}
func (m *TxOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOut.Merge(m, src)
}
func (m *TxOut) XXX_Size() int {
	return xxx_messageInfo_TxOut.Size(m)
}
func (m *TxOut) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOut.DiscardUnknown(m)
}

var xxx_messageInfo_TxOut proto.InternalMessageInfo

func (m *TxOut) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *TxOut) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *TxOut) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterType((*GenSeedRequest)(nil), "GenSeedRequest")
	proto.RegisterType((*GenSeedReply)(nil), "GenSeedReply")
	proto.RegisterType((*InitWalletRequest)(nil), "InitWalletRequest")
	proto.RegisterType((*InitWalletReply)(nil), "InitWalletReply")
	proto.RegisterType((*UnlockWalletRequest)(nil), "UnlockWalletRequest")
	proto.RegisterType((*UnlockWalletReply)(nil), "UnlockWalletReply")
	proto.RegisterType((*ChangePasswordRequest)(nil), "ChangePasswordRequest")
	proto.RegisterType((*ChangePasswordReply)(nil), "ChangePasswordReply")
	proto.RegisterType((*SendToManyRequest)(nil), "SendToManyRequest")
	proto.RegisterType((*SendToManyReply)(nil), "SendToManyReply")
	proto.RegisterType((*WalletAddressRequest)(nil), "WalletAddressRequest")
	proto.RegisterType((*WalletAddressReply)(nil), "WalletAddressReply")
	proto.RegisterType((*BalanceInfo)(nil), "BalanceInfo")
	proto.RegisterType((*WalletBalanceRequest)(nil), "WalletBalanceRequest")
	proto.RegisterType((*WalletBalanceReply)(nil), "WalletBalanceReply")
	proto.RegisterMapType((map[string]*BalanceInfo)(nil), "WalletBalanceReply.BalanceEntry")
	proto.RegisterType((*TxOut)(nil), "TxOut")
}

func init() { proto.RegisterFile("wallet.proto", fileDescriptor_b88fd140af4deb6f) }

var fileDescriptor_b88fd140af4deb6f = []byte{
	// 685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x6f, 0xda, 0x4a,
	0x10, 0x16, 0x38, 0x40, 0x32, 0x38, 0x01, 0x16, 0x88, 0x90, 0x4f, 0x3c, 0xbf, 0xc3, 0x23, 0xaf,
	0xea, 0x22, 0x91, 0x4b, 0x9a, 0x48, 0x91, 0x9a, 0xaa, 0x6a, 0x53, 0x29, 0x6a, 0xe4, 0xa4, 0xaa,
	0xd4, 0x0b, 0x5a, 0xf0, 0x84, 0x58, 0x31, 0x6b, 0x6a, 0xaf, 0x6b, 0xfc, 0x57, 0xb4, 0xe7, 0xfe,
	0xb5, 0x95, 0xd7, 0x3f, 0xb0, 0xb1, 0x4f, 0xbd, 0x79, 0xbf, 0x99, 0xf9, 0x3e, 0xcf, 0xee, 0x7c,
	0x03, 0x6a, 0xc0, 0x6c, 0x1b, 0x05, 0xdd, 0xb8, 0x8e, 0x70, 0xf4, 0x2e, 0x9c, 0x7c, 0x40, 0xfe,
	0x80, 0x68, 0x1a, 0xf8, 0xdd, 0x47, 0x4f, 0xe8, 0xe7, 0xa0, 0x66, 0xc8, 0xc6, 0x0e, 0xc9, 0xbf,
	0x70, 0xec, 0x21, 0x9a, 0xf3, 0x35, 0xc7, 0xb5, 0xc3, 0xad, 0xe5, 0xa8, 0x36, 0x56, 0x26, 0x47,
	0x86, 0x1a, 0x81, 0x77, 0x09, 0xa6, 0x33, 0xe8, 0xdd, 0x72, 0x4b, 0x7c, 0x95, 0xd4, 0x09, 0x13,
	0xf9, 0x0f, 0x3a, 0xb1, 0xd6, 0x7c, 0xc3, 0x3c, 0x2f, 0x70, 0x5c, 0x73, 0x54, 0x1b, 0xd7, 0x26,
	0xaa, 0x71, 0x12, 0xc3, 0xf7, 0x09, 0x5a, 0x96, 0xa8, 0x57, 0x48, 0xf4, 0xa0, 0x93, 0x97, 0xd8,
	0xd8, 0xa1, 0x7e, 0x0d, 0xfd, 0x2f, 0xdc, 0x76, 0x96, 0x2f, 0x7f, 0xa7, 0xab, 0xf7, 0xa1, 0x57,
	0xac, 0x8f, 0x48, 0x11, 0x86, 0xef, 0x9e, 0x19, 0x5f, 0x61, 0x9a, 0x96, 0xd2, 0x9e, 0x41, 0x77,
	0xe9, 0xbb, 0x2e, 0xf2, 0x12, 0x6f, 0x27, 0xc1, 0xb3, 0x86, 0xfe, 0x01, 0x95, 0x63, 0xb0, 0x4b,
	0xab, 0xcb, 0xb4, 0x36, 0xc7, 0x20, 0xd3, 0x1e, 0x42, 0x7f, 0x5f, 0x26, 0x52, 0xf7, 0xa1, 0xf7,
	0x80, 0xdc, 0x7c, 0x74, 0xee, 0x18, 0x0f, 0x53, 0xe5, 0x31, 0xb4, 0x1c, 0x5f, 0x6c, 0x7c, 0xe1,
	0xc9, 0xcb, 0x6f, 0xcf, 0x9a, 0xf4, 0x71, 0xfb, 0xd9, 0x17, 0x46, 0x0a, 0x93, 0xff, 0xa1, 0xb7,
	0xb6, 0x6c, 0xdb, 0xf2, 0x98, 0x98, 0x6f, 0xd0, 0x9d, 0x2f, 0x42, 0x81, 0x52, 0x55, 0x31, 0x3a,
	0x69, 0xe0, 0x1e, 0xdd, 0x9b, 0x50, 0x20, 0x21, 0x70, 0xb0, 0xf1, 0xbd, 0xe7, 0x91, 0x32, 0xae,
	0x4d, 0x0e, 0x0d, 0xf9, 0xad, 0x4f, 0xa0, 0x93, 0x97, 0x8d, 0xde, 0x7d, 0x08, 0x4d, 0x97, 0x05,
	0x73, 0xb1, 0x4d, 0x9a, 0x6c, 0xb8, 0x2c, 0x78, 0xdc, 0xea, 0xa7, 0x30, 0x88, 0x6f, 0xeb, 0xad,
	0x69, 0xba, 0xe8, 0x79, 0xe9, 0xd8, 0x7c, 0x02, 0xb2, 0x87, 0x47, 0x24, 0x23, 0x68, 0xb1, 0xf8,
	0x2c, 0x59, 0x8e, 0x8c, 0xf4, 0x48, 0x34, 0x38, 0x5c, 0xd8, 0x16, 0x37, 0x2d, 0xbe, 0x92, 0x3f,
	0x7a, 0x64, 0x64, 0x67, 0xfd, 0x57, 0x0d, 0xda, 0x37, 0xcc, 0x66, 0x7c, 0x89, 0xb7, 0xfc, 0xc9,
	0x89, 0xe6, 0x43, 0x38, 0x82, 0xd9, 0xf3, 0x45, 0x0c, 0x4a, 0xae, 0x03, 0x43, 0x95, 0x60, 0x92,
	0x48, 0x5e, 0x41, 0x6f, 0xe9, 0xf0, 0x27, 0xcb, 0x5d, 0xa3, 0x99, 0x25, 0xd6, 0x65, 0x62, 0x37,
	0x0b, 0xa4, 0xc9, 0x53, 0xe8, 0xfb, 0xbc, 0x9c, 0xae, 0xc8, 0x74, 0x92, 0x0b, 0x25, 0x05, 0xbb,
	0xb6, 0x13, 0x20, 0x6d, 0xfb, 0x77, 0x2d, 0xed, 0x3b, 0x0b, 0x44, 0x7d, 0x5f, 0x42, 0x6b, 0xf7,
	0xaf, 0xd1, 0x8b, 0x8d, 0x69, 0x39, 0x8b, 0x26, 0x87, 0xf7, 0x5c, 0xb8, 0xa1, 0x91, 0x16, 0x68,
	0x1f, 0x41, 0xcd, 0x07, 0x48, 0x17, 0x94, 0x17, 0x0c, 0x93, 0xfb, 0x8b, 0x3e, 0x89, 0x0e, 0x8d,
	0x1f, 0xcc, 0xf6, 0xe3, 0xf6, 0xda, 0x33, 0x95, 0xe6, 0x2e, 0xcb, 0x88, 0x43, 0x97, 0xf5, 0x8b,
	0x9a, 0x7e, 0x07, 0x0d, 0x39, 0x27, 0x64, 0x00, 0x0d, 0xe6, 0x79, 0x28, 0x12, 0x92, 0xf8, 0x10,
	0xa1, 0x3b, 0x1a, 0x25, 0x29, 0xcc, 0x3f, 0x99, 0x52, 0x78, 0xb2, 0xd9, 0x4f, 0x05, 0x9a, 0x71,
	0x17, 0xe4, 0x0c, 0x5a, 0xc9, 0x92, 0x20, 0x1d, 0x5a, 0x5c, 0x20, 0xda, 0x31, 0x2d, 0xec, 0x8f,
	0x19, 0xc0, 0xce, 0xb7, 0x84, 0xd0, 0xd2, 0x9e, 0xd0, 0xba, 0x74, 0xcf, 0xd8, 0xe4, 0x02, 0xd4,
	0xbc, 0x31, 0xc9, 0x80, 0x56, 0xf8, 0x5c, 0x23, 0xb4, 0xe4, 0x5e, 0x72, 0x0d, 0x27, 0x45, 0x5b,
	0x91, 0x53, 0x5a, 0x69, 0x67, 0x6d, 0x40, 0x2b, 0xfc, 0x47, 0xae, 0xe0, 0xb8, 0x30, 0xc6, 0x64,
	0x48, 0xab, 0xc6, 0x5d, 0xeb, 0xd3, 0x8a, 0x69, 0xcf, 0x8a, 0xd3, 0x31, 0x1b, 0xd2, 0xaa, 0xa1,
	0xc9, 0x8a, 0x0b, 0x23, 0x33, 0x03, 0xd8, 0x59, 0x90, 0x10, 0x5a, 0x5a, 0x03, 0x5a, 0x97, 0xee,
	0x79, 0xf4, 0xe6, 0xea, 0xdb, 0x9b, 0x95, 0x25, 0x9e, 0xfd, 0x05, 0x5d, 0x3a, 0xeb, 0xa9, 0x30,
	0x71, 0xfb, 0x9a, 0xa3, 0x08, 0x1c, 0xf7, 0x25, 0x3e, 0xc8, 0x1d, 0xbf, 0xf0, 0x9f, 0xa6, 0x2b,
	0xe4, 0xe8, 0x32, 0x81, 0xe6, 0x74, 0xe5, 0x4c, 0xe3, 0x2d, 0xb8, 0x68, 0xca, 0xe8, 0xf9, 0x9f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x9d, 0xb8, 0x8b, 0xfd, 0x11, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WalletClient is the client API for Wallet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WalletClient interface {
	//
	//GenSeed is the first method that should be used to instantiate a new tdexd
	//instance. This method allows a caller to generate a new HD Wallet.
	//Once the seed is obtained and verified by the user, the InitWallet
	//method should be used to commit the newly generated seed, and create the
	//wallet.
	GenSeed(ctx context.Context, in *GenSeedRequest, opts ...grpc.CallOption) (*GenSeedReply, error)
	//
	//InitWallet is used when tdexd is starting up for the first time to fully
	//initialize the daemon and its internal wallet. At the very least a mnemonic
	//and a wallet password must be provided. This will be used to encrypt sensitive
	//material on disk. Alternatively, this can be used along with the GenSeed RPC
	//to obtain a seed, then present it to the user. Once it has been verified by
	//the user, the seed can be fed into this RPC in order to commit the new wallet.
	InitWallet(ctx context.Context, in *InitWalletRequest, opts ...grpc.CallOption) (*InitWalletReply, error)
	//
	//UnlockWallet is used at startup of tdexd to provide a password to unlock
	//the wallet database.
	UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletReply, error)
	//
	//ChangePassword changes the password of the encrypted wallet. This will
	//automatically unlock the wallet database if successful.
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordReply, error)
	//
	//WalletAddress returns a Liquid confidential p2wpkh address (BLECH32)
	WalletAddress(ctx context.Context, in *WalletAddressRequest, opts ...grpc.CallOption) (*WalletAddressReply, error)
	//
	//WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
	//confirmed unspent outputs and all unconfirmed unspent outputs under control
	//of the wallet.
	WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceReply, error)
	//SendToMany sends funds to many outputs
	SendToMany(ctx context.Context, in *SendToManyRequest, opts ...grpc.CallOption) (*SendToManyReply, error)
}

type walletClient struct {
	cc *grpc.ClientConn
}

func NewWalletClient(cc *grpc.ClientConn) WalletClient {
	return &walletClient{cc}
}

func (c *walletClient) GenSeed(ctx context.Context, in *GenSeedRequest, opts ...grpc.CallOption) (*GenSeedReply, error) {
	out := new(GenSeedReply)
	err := c.cc.Invoke(ctx, "/Wallet/GenSeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) InitWallet(ctx context.Context, in *InitWalletRequest, opts ...grpc.CallOption) (*InitWalletReply, error) {
	out := new(InitWalletReply)
	err := c.cc.Invoke(ctx, "/Wallet/InitWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletReply, error) {
	out := new(UnlockWalletReply)
	err := c.cc.Invoke(ctx, "/Wallet/UnlockWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordReply, error) {
	out := new(ChangePasswordReply)
	err := c.cc.Invoke(ctx, "/Wallet/ChangePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) WalletAddress(ctx context.Context, in *WalletAddressRequest, opts ...grpc.CallOption) (*WalletAddressReply, error) {
	out := new(WalletAddressReply)
	err := c.cc.Invoke(ctx, "/Wallet/WalletAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceReply, error) {
	out := new(WalletBalanceReply)
	err := c.cc.Invoke(ctx, "/Wallet/WalletBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SendToMany(ctx context.Context, in *SendToManyRequest, opts ...grpc.CallOption) (*SendToManyReply, error) {
	out := new(SendToManyReply)
	err := c.cc.Invoke(ctx, "/Wallet/SendToMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletServer is the server API for Wallet service.
type WalletServer interface {
	//
	//GenSeed is the first method that should be used to instantiate a new tdexd
	//instance. This method allows a caller to generate a new HD Wallet.
	//Once the seed is obtained and verified by the user, the InitWallet
	//method should be used to commit the newly generated seed, and create the
	//wallet.
	GenSeed(context.Context, *GenSeedRequest) (*GenSeedReply, error)
	//
	//InitWallet is used when tdexd is starting up for the first time to fully
	//initialize the daemon and its internal wallet. At the very least a mnemonic
	//and a wallet password must be provided. This will be used to encrypt sensitive
	//material on disk. Alternatively, this can be used along with the GenSeed RPC
	//to obtain a seed, then present it to the user. Once it has been verified by
	//the user, the seed can be fed into this RPC in order to commit the new wallet.
	InitWallet(context.Context, *InitWalletRequest) (*InitWalletReply, error)
	//
	//UnlockWallet is used at startup of tdexd to provide a password to unlock
	//the wallet database.
	UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletReply, error)
	//
	//ChangePassword changes the password of the encrypted wallet. This will
	//automatically unlock the wallet database if successful.
	ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordReply, error)
	//
	//WalletAddress returns a Liquid confidential p2wpkh address (BLECH32)
	WalletAddress(context.Context, *WalletAddressRequest) (*WalletAddressReply, error)
	//
	//WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
	//confirmed unspent outputs and all unconfirmed unspent outputs under control
	//of the wallet.
	WalletBalance(context.Context, *WalletBalanceRequest) (*WalletBalanceReply, error)
	//SendToMany sends funds to many outputs
	SendToMany(context.Context, *SendToManyRequest) (*SendToManyReply, error)
}

// UnimplementedWalletServer can be embedded to have forward compatible implementations.
type UnimplementedWalletServer struct {
}

func (*UnimplementedWalletServer) GenSeed(ctx context.Context, req *GenSeedRequest) (*GenSeedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenSeed not implemented")
}
func (*UnimplementedWalletServer) InitWallet(ctx context.Context, req *InitWalletRequest) (*InitWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitWallet not implemented")
}
func (*UnimplementedWalletServer) UnlockWallet(ctx context.Context, req *UnlockWalletRequest) (*UnlockWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockWallet not implemented")
}
func (*UnimplementedWalletServer) ChangePassword(ctx context.Context, req *ChangePasswordRequest) (*ChangePasswordReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (*UnimplementedWalletServer) WalletAddress(ctx context.Context, req *WalletAddressRequest) (*WalletAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletAddress not implemented")
}
func (*UnimplementedWalletServer) WalletBalance(ctx context.Context, req *WalletBalanceRequest) (*WalletBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletBalance not implemented")
}
func (*UnimplementedWalletServer) SendToMany(ctx context.Context, req *SendToManyRequest) (*SendToManyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendToMany not implemented")
}

func RegisterWalletServer(s *grpc.Server, srv WalletServer) {
	s.RegisterService(&_Wallet_serviceDesc, srv)
}

func _Wallet_GenSeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenSeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GenSeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/GenSeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GenSeed(ctx, req.(*GenSeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_InitWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).InitWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/InitWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).InitWallet(ctx, req.(*InitWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_UnlockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).UnlockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/UnlockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).UnlockWallet(ctx, req.(*UnlockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/ChangePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_WalletAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).WalletAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/WalletAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).WalletAddress(ctx, req.(*WalletAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_WalletBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).WalletBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/WalletBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).WalletBalance(ctx, req.(*WalletBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SendToMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SendToMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Wallet/SendToMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SendToMany(ctx, req.(*SendToManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Wallet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Wallet",
	HandlerType: (*WalletServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenSeed",
			Handler:    _Wallet_GenSeed_Handler,
		},
		{
			MethodName: "InitWallet",
			Handler:    _Wallet_InitWallet_Handler,
		},
		{
			MethodName: "UnlockWallet",
			Handler:    _Wallet_UnlockWallet_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _Wallet_ChangePassword_Handler,
		},
		{
			MethodName: "WalletAddress",
			Handler:    _Wallet_WalletAddress_Handler,
		},
		{
			MethodName: "WalletBalance",
			Handler:    _Wallet_WalletBalance_Handler,
		},
		{
			MethodName: "SendToMany",
			Handler:    _Wallet_SendToMany_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "wallet.proto",
}
